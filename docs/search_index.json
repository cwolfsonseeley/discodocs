[
["index.html", "Documentation for discoveryengine 1 Disco 1.1 Contribute to the Disco Engine 1.2 Contribute to this documentation", " Documentation for discoveryengine Tarak Shah 2017-02-23 1 Disco Welcome to the introduction and extended documentation for the discoveryengine! The discoveryengine, also known as “Disco Engine” or just “Disco,” is a tool enabling Prospect Development staff to do custom prospecting, written in the R programming language. Feel free to read this document in order, or to jump around or just bookmark it and refer to it as needed. You may find the search feature helpful, you can access it by clicking on the little magnifying glass at the top of the screen. 1.1 Contribute to the Disco Engine The Disco Engine is a tool made by and for Prospect Development. If you see something that doesn’t work correctly, or documentation that could be made clearer, or a widget that would be useful that isn’t implemented, or anything at all that could be improved in the Disco Engine, please submit an issue by clicking on the green “New Issue” button on the Disco engine issues page. 1.2 Contribute to this documentation This site is a work in progress. One way you can help is to report any mistakes you find (typos, spelling mistakes, grammatical errors) or any areas that could be explained better (if something was not clear to you, there’s a good chance it won’t be clear to others either). This documentation site has its own Disco-docs issues page – click on the green “New Issue” button and enter a short message explaining what’s wrong. If you’d like to suggest edits directly, you can do so by clicking on the pen-and-paper icon at the top of any page on this site (guide coming soon). Thank you! "],
["r-intro.html", "2 Introduction to R and RStudio", " 2 Introduction to R and RStudio The discoveryengine works best when used with RStudio. Watch this video for a quick tour around RStudio: "],
["installation.html", "3 Installation 3.1 Required packages 3.2 A disco test", " 3 Installation In order to use the discoveryengine, you’ll have to install it. And in order to successfully install the discoveryengine, you’ll have to install a few other packages, too. The introduction to RStudio video showed you how to install new packages both by typing install commands into the console, or by using RStudio’s “Packages” pane. Here, we’ll go through the installation step-by-step by typing out the install commands (copying and pasting is a good way to avoid frustrating typos!). Note that installation can sometimes be a pain. But once you’ve gotten through the process successfully, you won’t have to deal with it again! 3.1 Required packages At this point, you should have already: tested your CDW connection installed getcdw run a test query If you haven’t completed all of those items, head over to the step-by-step guide and complete those steps, and then return here. Ok, so if you’ve got getcdw working properly, that means you’ve already installed devtools. All that’s left is to install listbuilder and discoveryengine packages: devtools::install_github(&quot;tarakc02/listbuilder&quot;) devtools::install_github(&quot;tarakc02/discoveryengine&quot;) There are a couple more packages that are optional, but will make the discoveryengine even better: devtools::install_github(&quot;tarakc02/preprocessr&quot;) install.packages(&quot;DT&quot;) 3.2 A disco test In order to make sure everything is working properly, we’ll run a quick disco test: # you&#39;ll always load the discoveryengine package before doing anythying else library(discoveryengine) # make sure we can create a disco definition high_cap = has_capacity(1) # make sure that things print properly high_cap ## LISTBUILDER DEFINITION (type: entity_id) ## . source: d_entity_mv.entity_id (entity_id) ## . logic: capacity_rating_code IN 1 # make sure we can send the defintion to the data warehouse display(high_cap) ## # A tibble: 169 x 1 ## entity_id ## &lt;dbl&gt; ## 1 1969 ## 2 3105 ## 3 3422 ## 4 7644 ## 5 12178 ## 6 17464 ## 7 18139 ## 8 20039 ## 9 20125 ## 10 20227 ## # ... with 159 more rows If you got this far without any problems, then congrats! You are a disco dancer! "],
["intro-example.html", "4 An introductory example 4.1 Develop a strategy 4.2 Create the definition 4.3 Send the definition to the CDW", " 4 An introductory example Before diving in to details, let’s work through a simple real-life example. We’ll explain the functions used in more detail in later sections, but here you can see what the tool looks like in action. Here is our scenario: A fundraiser just called, and is trying to organize an event in San Francisco that will feature a well-known technologist. She wants you to help her find prospects to invite to the event. We start out by loading the discoveryengine: library(discoveryengine) 4.1 Develop a strategy You might already be thinking of what sorts of prospects we should look for. That’s good! There are countless ways to respond to this request, and you’ll have to rely on your own expertise in order to know who to include on a potential invite list. For this example, I’ll use the following definition of a good prospect: has demonstrated an interest in technology, and … lives or works in/near San Francisco Note that we now have a pretty clear idea of who to look for, but we need more precision. For instance, what constitutes a “demonstrated interest in technology?” What does it mean to be “in/near San Francisco?” In day-to-day conversations, we don’t necessarily need that level of precision to understand one another, but since we’ll need to translate this request into language a computer can understand, the more precision the better. I’ll define a “demonstrated interest in technology” as having either an interest code or a philanthropic affinity related to technology, and “in/near San Francisco” as anywhere that falls into the San Francisco Metropolitan Statistical Area (MSA). 4.2 Create the definition So now that we have a precise idea of who we want to find, we can create a definition that the computer will understand. This is important, since our computer is the only link we have to the CADS Data Warehouse. We can give it a precise definition in a language that it understands, and it will then relay our request to the CADS Data Warehouse. The CADS data warehouse can then search for people who meet our definition, and send them back to the computer, which will then display the list to us. Ideally, our definition would look like this: has_tech_interest %and% is_in_sf. Of course, we haven’t defined those pieces yet, so just typing that in will result in an error has_tech_interest %and% is_in_sf ## Error in operate(block1, block2, &quot;intersect&quot;): object &#39;has_tech_interest&#39; not found But still we’ve made progress. We broke a big problem (“define a prospect for this SF tech event”) into two smaller problems (“define having a tech interest” and “define being in San Francisco”). Let’s tackle each of these one by one. We start by defining has_tech_interest. Recall that we decided to use interest codes and philanthropic affinities here. I happen to already know that there is an interest code for “technology”, but I’m less familiar with the philanthropic affinities area. So I’ll use the search feature that is built into most widgets, accessed by entering a question mark followed by a search term into the widget: has_philanthropic_affinity(?tech) ## synonym code ## science_technology ST Ah, ok. I can use either the code ST or the synonym science_technology. has_tech_interest = has_interest(technology) %or% has_philanthropic_affinity(science_technology) We use %or% as the connector here because we’re interested in anyone who has either one of these characteristics. We now move to defining is_in_sf. We’d like to look for anyone who lives or works in San Francisco: is_in_sf = lives_in_msa(san_francisco) %or% works_in_msa(san_francisco) We are now able to create our full definition by combining the pieces: event_prospect = has_tech_interest %and% is_in_sf 4.3 Send the definition to the CDW As we discussed in the previous section, now that we have an official definition we can send it to the data warehouse, and see if the data warehouse finds anyone who fits. You can see the definition for yourself by just typing the name of it, though it is now written in a language for the computer to understand and may look intimidating to us humans: event_prospect ## LISTBUILDER DEFINITION (type: entity_id) ## . operator (AG61): intersect ## . left (AG61): ## . . operator (MD78): union ## . . left (MD78): ## . . . source: d_bio_interest_mv.entity_id (entity_id) ## . . . logic: interest_code IN &#39;TEC&#39; ## . . right (MD78): ## . . . source: d_oth_phil_affinity_mv.entity_id (entity_id) ## . . . logic: ## . . . . other_affinity_type IN &#39;ST&#39; ## . . . . sum(gift_amt) &gt;= 0.0 ## . right (AG61): ## . . operator (UY21): union ## . . left (UY21): ## . . . source: d_bio_address_mv.entity_id (entity_id) ## . . . logic: ## . . . . geo_metro_area_code IN &#39;41860&#39; ## . . . . addr_type_code IN &#39;H&#39; ## . . right (UY21): ## . . . source: d_bio_address_mv.entity_id (entity_id) ## . . . logic: ## . . . . geo_metro_area_code IN &#39;41860&#39; ## . . . . addr_type_code IN &#39;B&#39; In order to send the definition to the data warehouse, retrieve the results, and show them to us, we use the display function: display(event_prospect) ## # A tibble: 689 x 1 ## entity_id ## &lt;dbl&gt; ## 1 11535 ## 2 27562 ## 3 32528 ## 4 367399 ## 5 43187 ## 6 145337 ## 7 211715 ## 8 257211 ## 9 263076 ## 10 278872 ## # ... with 679 more rows Of course, we are probably interested in exporting this savedlist to a file, so that we might load it into CADS and run CADSmart reports on it. Conveniently, we can just do that by adding a filename: display(event_prospect, file = &quot;sf-tech-prospects&quot;) Now when I look over at my working directory, there’s a new file called sf-tech-prospects.csv "],
["working-with-widgets.html", "5 Working with widgets 5.1 Finding widgets 5.2 Codes and synonyms 5.3 Synonym search 5.4 Use the default cases 5.5 Detailed controls 5.6 Combining widgets 5.7 Combination example 5.8 Combination example 2", " 5 Working with widgets So far, we’ve used widgets in some simple examples. In this section, we’ll explore widgets in some more detail. As always, we’ll begin by loading the discoveryengine: library(discoveryengine) 5.1 Finding widgets There are two main ways to find widgets. The first is to use the show_widgets function. The function takes no arguments. When you run it, an interactive list of widgets, with short descriptions of each, will appear in your viewer window: show_widgets() You can browse the entire listing, or use the search bar at the top right to search for specific widgets. The second way to search for widgets is to use the widget_for function. This function takes as an argument a search term, and finds all widgets that are related to that search term. For example: widget_for(&quot;giving&quot;) ## fund_area: ## Find funds with a particular area of giving code (type: allocation_code) ## fund_department: ## Find funds with a particular department code (type: allocation_code) ## fund_miner: ## Entities who gave to funds that match a keyword search (type: entity_id) ## fund_text_contains: ## Funds with notes/biographies that contain the specified search string(s) (type: allocation_code) ## gave_to_area: ## Lists entities who gave to specific areas with minimum giving and specific date range (type: entity_id) ## gave_to_department: ## Lists entities who gave to specific departments with minimum giving and specific date range (type: entity_id) ## gave_to_fund: ## Entities who have given to specified funds (type: entity_id) ## has_philanthropic_affinity: ## Lists entities with philanthropic affinity(ies) (type: entity_id) Once you’ve found the widget you’re looking for, you can get additional information using R’s built-in help system. Just type a question mark followed by the name of the widget, e.g. ?gave_to_area. 5.2 Codes and synonyms You may have noticed in previous examples that widgets work with exact codes, such as in_unit_portfolio(BU) or with synonyms, such as in_unit_portfolio(business). Synonyms will always be in lower-case, and may include any letter of the alphabet or the underscore “_&quot; character, and nothing else. Use whichever feels more comfortable – there is no advantage to using codes vs. synonyms, though I personally find the synonyms easier to read and understand later on. 5.3 Synonym search If you’re not sure of the code or synonym to use, try out the synonym search feature that works with most widgets. Instead of entering a code (in_unit_portfolio(BU)) or synonym (in_unit_portfolio(business)), enter a question mark followed by a search string: in_unit_portfolio(?business) ## synonym code ## business BU You can enter partial terms: in_unit_portfolio(?sci) ## synonym code ## lawrence_hall_of_science LH ## neuroscience_institute NS ## qb3_quantitative_biosciences QB ## letters_science LS ## greater_good_science_center GG ## letters_and_science LS ## neuroscience NS ## quantitative_bioscience QB ## quantitative_biosciences QB And even multiple search terms: in_unit_portfolio(?bus, ?chem, ?public) ## synonym code ## business BU ## chemistry CH ## public_health PH ## communications_public_affairs PA ## public_policy PP Widgets can always accept multiple codes/synonyms as arguments, and even combinations of the two: gave_to_area(business) would find anyone who has given to the school of Business gave_to_area(business, chemistry) would find anyone who has given to Business or to Chemistry gave_to_area(HSB, COC) is the same as above gave_to_area(business, COC) once again, the same thing 5.4 Use the default cases So by now you can probably figure out that partcipated_in(uc_jazz_ensembles) gets you alumni who participated in the UC Jazz Ensembles. But what if you’re actually looking for people who particpated in any student activity at all? Would you have to type out all (hundreds!) of them? Luckily, no! In fact, all you have to do is type participated_in(): did_anything = participated_in() display(did_anything) ## # A tibble: 211,397 x 1 ## entity_id ## &lt;dbl&gt; ## 1 479293 ## 2 978671 ## 3 698424 ## 4 882164 ## 5 378663 ## 6 642319 ## 7 645485 ## 8 583924 ## 9 3063211 ## 10 790879 ## # ... with 211,387 more rows That seems a bit magical, doesn’t it? The reason that works is because every widget has a defined behavior for when no codes/synonyms are entered. These default behaviors aim to be sensible so that you can use them in an intuitive way. You can always find out exactly what is included in the default by using the help. For instance, by typing ?has_capacity I find out that entering has_capacity() without any specific ratings will find anyone with a researched capacity rating between 1 and 14 (so 99’s are excluded, and those with no capacity ratings are excluded). 5.5 Detailed controls We saw above that gave_to_area(business) will find people who have given to the Haas School of Business. By default, this will find anyone who has ever given any amount, at any time. But gave_to_area, like many widgets, has a number of optional arguments that allow more fine-grained control. For example: gave_to_area(business, at_least = 10000): finds anyone who has given at least $10,000 lifetime to the school of Business. gave_to_area(business, at_least = 10000, from = 20160101): finds anyone who has given at least $10,000 to Business since the beginning of 2016. gave_to_area(business, at_least = 10000, from = 20150101, to = 20151231): finds anyone who gave at least $10,000 to Business between January 1, 2015 and December 31, 2015. gave_to_area(business, from = 20150101, to = 20151231): finds anyone who gave anything at all to the school of Business between January 1, 2015 and December 31, 2015 As you can see, you can pick and choose which optional arguments you want to use. To find out all of the possible controls for a widget, use the built in help. For example, type ?gave_to_area. 5.6 Combining widgets As flexible as individual widgets are, they won’t help you too much by themselves. What makes them really useful is that they can be combined. There are three ways to combine widgets: %and% will look for entities who satisfy both widgets %or% will look for entities who satisfy at least one of two widgets %but_not% will look for entities who satisfy a widget but do not satisfy a second widget. Some quick examples: gave_to_area(art_museum) %and% gave_to_area(cal_performances) finds anyone who has given to both the Art Museum and Cal Performances. gave_to_area(art_museum) %or% gave_to_area(cal_performances) finds anyone who has ever given to either the Art Museum or to Cal Performances. Note that this would include everyone who was found in the previous (%and%) example, as well as those who only gave to one or the other area. gave_to_area(art_museum) %but_not% gave_to_area(cal_performances) finds anyone who has given to the Art Museum but has not given to Cal Performances. 5.7 Combination example You’re working with a major gift officer in the School of Business who is surprised to find out that alumni have been giving $15,000+ gifts in response to annual appeals, with no follow-up from major gift officers. She calls you up and says: I need to a report on everyone who has given $15,000 or more this year who isn’t yet in a portfolio, and I need it right away! You could probably have a savedlist ready before she’s even hung up the phone: important_prospects = gave_to_area(business, at_least = 15000, from = 20160101) %but_not% in_unit_portfolio(business) display(important_prospects) ## # A tibble: 74 x 1 ## entity_id ## &lt;dbl&gt; ## 1 878167 ## 2 741407 ## 3 433145 ## 4 23984 ## 5 3106890 ## 6 1008005 ## 7 612156 ## 8 3152758 ## 9 3083791 ## 10 21159 ## # ... with 64 more rows 5.8 Combination example 2 So you create your savedlist, run a Prospect Pool Spreadsheet on it, review the results, and send the data and your analysis over to the major gift officer. She notices that several of the people on the list had been in portfolios earlier, so asks if you can find just those who have never been in a portfolio. You start out by checking if the portfolio widget has any options regarding inactive proposal assignments, by typing ?in_unit_portfolio. You see that yes, indeed, there is an option called include_inactive that defaults to FALSE. If you instead set it to TRUE by typing in_unit_portfolio(business, include_inactive = TRUE), you’d be capturing anyone who has ever been in a Business portfolio, and you can again use %but_not% to subtract those people from the donor list: important_prospects = gave_to_area(business, at_least = 15000, from = 20160101) %but_not% in_unit_portfolio(business, include_inactive = TRUE) display(important_prospects) ## # A tibble: 61 x 1 ## entity_id ## &lt;dbl&gt; ## 1 878167 ## 2 433145 ## 3 23984 ## 4 3106890 ## 5 1008005 ## 6 612156 ## 7 3152758 ## 8 3083791 ## 9 393692 ## 10 3145542 ## # ... with 51 more rows "],
["brainstorm-bot.html", "6 The Brainstorm Bot 6.1 Search features", " 6 The Brainstorm Bot # as always, i have to make sure the disco engine is loaded library(discoveryengine) At this point, you’re pretty empowered to search through the database for all sorts of prospects, provided you know something about the codes in the database. Even if you don’t know the exact code for, say, basketball, you can use the synonym search feature because you know which widget to use: played_sport(?basketball) ## synonym code ## basketball_men MABB ## basketball_women WABB ## cal_basketball_club RSBK But now imagine someone has asked you for a list of people interested in robotics. Where would that be coded? Perhaps in multiple places? How can you find out? Enter the brainstorm bot. The brainstorm bot is a robot that is knowledgeable about the code tables in CADS. Let’s ask it about robotics: brainstorm_bot(&quot;robotics&quot;) ## has_interest ## ROB: Robotics ## participated_in ## ENRO: Cal Robotics Hey brainstorm bot, thanks for the ideas! The results show the name of a widget, along with the codes that are of interest, along with their description from the CADS code tables, so you can decide if they are appropriate for your project. You can then copy and paste to build up the right population: display(has_interest(ROB)) ## # A tibble: 1 x 1 ## entity_id ## &lt;dbl&gt; ## 1 470691 If it turns out you agree with every one of the brainstorm bot’s suggestions, then you don’t even have to copy and paste, because (surprise!) the brainstorm bot is actually giving you a fully filled out widget: # if i wanted robotics fans in the san francisco MSA prospects = brainstorm_bot(&quot;robotics&quot;) %and% lives_in_msa(san_francisco) display(prospects) ## # A tibble: 5 x 1 ## entity_id ## &lt;dbl&gt; ## 1 718587 ## 2 749416 ## 3 823913 ## 4 875964 ## 5 824900 6.1 Search features The brainstorm bot understands wildcards at the beginning and/or ending of your search term: brainstorm_bot(&quot;robot*&quot;) ## attended_event ## 6724: Haas East Bay Chp Robotic Event 06-18-14 ## has_interest ## ROB: Robotics ## participated_in ## ENRO: Cal Robotics ## UROB: Robotmedia Presents It also will do multiple searches at once: brainstorm_bot(&quot;robot*&quot;, &quot;data science&quot;) ## attended_event ## 6724: Haas East Bay Chp Robotic Event 06-18-14 ## gave_to_department ## DT: Berkeley Institute for Data Science ## has_interest ## DAT: Data Science ## ROB: Robotics ## majored_in ## 2E0: Master of Information &amp; Data Science ## participated_in ## ENRO: Cal Robotics ## UROB: Robotmedia Presents "],
["higher-order-widgets.html", "7 Higher order widgets 7.1 Children of wealth", " 7 Higher order widgets You may have noticed when we ran the show_widgets() function in working with widgets that there is a mysterious “Order” column that categorizes widgets as either “first-order” or “second-order”. What’s that all about? In order to answer that, let’s take a look at another example. 7.1 Children of wealth Many alumni in our database do not have capacity ratings, but come from wealthy families. This would be nice to be aware of if they were ever being solicited. But how could we identify these “children of wealth” using the discovery engine? It’s pretty easy to find wealthy individuals: # as always, i make sure the disco engine is loaded library(discoveryengine) # i&#39;ll define wealthy as a capacity of $1 Million+ wealthy = has_capacity(1:7) But now I’m stuck. I want to find children of anyone on that list. But so far all of the widgets we’ve seen work with specific codes, not other widgets. Technically, all the widgets we’ve seen are first-order widgets. But we do have some widgets that, instead of working on one or more specific codes, works on an existing, already filled out widget. child_of is one such second-order widget: child_of_wealth = child_of(wealthy) display(child_of_wealth) ## # A tibble: 1,024 x 1 ## entity_id ## &lt;dbl&gt; ## 1 501819 ## 2 633358 ## 3 3009776 ## 4 684446 ## 5 30621 ## 6 731797 ## 7 325782 ## 8 734035 ## 9 31566 ## 10 26435 ## # ... with 1,014 more rows Though the syntax looks just like what we’ve been doing all along, note that wealthy in the above is not a code or synonym, but instead is the name that I gave to the definition has_capacity(1:7). This makes child_of very different from other widgets we’ve seen so far. As we’ll see in the next seciton, the ability to use second-order widgets allows us to do some very powerful things. The result of using a second-order widget, though, is just like using any other widget. You can continue to combine it with other widgets: display(child_of_wealth %and% lives_in_msa(san_francisco)) ## # A tibble: 448 x 1 ## entity_id ## &lt;dbl&gt; ## 1 501819 ## 2 731797 ## 3 325782 ## 4 415779 ## 5 30775 ## 6 30776 ## 7 459195 ## 8 28210 ## 9 21477 ## 10 433145 ## # ... with 438 more rows # or even display( child_of(child_of_wealth) ) ## # A tibble: 118 x 1 ## entity_id ## &lt;dbl&gt; ## 1 684446 ## 2 1002656 ## 3 499074 ## 4 3211635 ## 5 945146 ## 6 509691 ## 7 3162983 ## 8 734034 ## 9 916909 ## 10 742372 ## # ... with 108 more rows "],
["non-entity-widgets.html", "8 Non-entity widgets 8.1 Motivation 8.2 Disco Definition Types 8.3 Searching fund text 8.4 From funds to entities 8.5 “Converters”", " 8 Non-entity widgets 8.1 Motivation In CADSmart, there is a report called the Fundfinder, which allows you to search for allocations that contain specific words or phrases in the name, fund terms, or fund biography. A natural application is to use the report to find some allocations, and then turn around and get a list of entities who have given to those funds. So far, we haven’t seen how to do that in the disco engine, but that’s about to change. Before reading this section, make sure you understand higher order widgets. 8.2 Disco Definition Types Let’s take a closer look at a widget we’ve already used a lot, the has_capacity widget. In particular, let’s look at the definition that gets created when we use has_capacity: has_capacity(1) ## LISTBUILDER DEFINITION (type: entity_id) ## . source: d_entity_mv.entity_id (entity_id) ## . logic: capacity_rating_code IN 1 See in parentheses in the first line where it says type: entity_id? So entity_id is the “type” of the definition we’ve created. And as you may have guessed by now, we can also create other types of definition! 8.3 Searching fund text The Fundfinder report does not give you a list of entities, it gives you a list of allocations. You are then expected to use a different report to find donors to those allocations. We’ll follow a similar (but hopefully more convenient) strategy with the disco engine. We start by using fund_text_contains to do a text search of fund terms/biographies/names (for more info, check the help file by typing ?fund_text_contains). fund_text_contains, like all text-searching tools in the discoveryengine, allows you to enter as many search terms as you like, and to use wildcards (*): # let&#39;s look for funds that support diversity/underrepresented students diversity_funds = fund_text_contains(&quot;divers*&quot;, &quot;underrepresented&quot;) The definition looks pretty complex, but notice that first line – this time around, instead of entity_id, we have type: allocation_code: diversity_funds ## LISTBUILDER DEFINITION (type: allocation_code) ## . operator (OI64): union ## . left (OI64): ## . . source: f_allocation_mv.allocation_code (allocation_code) ## . . logic: REGEXP_LIKE(long_name, &#39;((^|\\\\s|\\\\W)divers)|((^|\\\\s|\\\\W)underrepresented($|\\\\s|\\\\W))&#39;, &#39;i&#39;) ## . right (OI64): ## . . operator (IA60): union ## . . left (IA60): ## . . . operator (RJ90): union ## . . . left (RJ90): ## . . . . source: f_notes_mv.allocation_code (allocation_code) ## . . . . logic: ## . . . . . REGEXP_LIKE(description, &#39;((^|\\\\s|\\\\W)divers)|((^|\\\\s|\\\\W)underrepresented($|\\\\s|\\\\W))&#39;, &#39;i&#39;) ## . . . . . note_type IN (&#39;FT&#39;, &#39;FB&#39;) ## . . . right (RJ90): ## . . . . source: f_notes_mv.allocation_code (allocation_code) ## . . . . logic: ## . . . . . REGEXP_LIKE(brief_note, &#39;((^|\\\\s|\\\\W)divers)|((^|\\\\s|\\\\W)underrepresented($|\\\\s|\\\\W))&#39;, &#39;i&#39;) ## . . . . . note_type IN (&#39;FT&#39;, &#39;FB&#39;) ## . . right (IA60): ## . . . source: f_notes_mv.allocation_code (allocation_code) ## . . . logic: ## . . . . REGEXP_LIKE(note_text, &#39;((^|\\\\s|\\\\W)divers)|((^|\\\\s|\\\\W)underrepresented($|\\\\s|\\\\W))&#39;, &#39;i&#39;) ## . . . . note_type IN (&#39;FT&#39;, &#39;FB&#39;) And in fact, if we run display, we’ll see a list of allocation codes instead of the entity IDs that we’ve seen in previous examples: display(diversity_funds) ## # A tibble: 208 x 1 ## allocation_code ## &lt;chr&gt; ## 1 FB0807000 ## 2 FM8294000 ## 3 FN1251000 ## 4 FN1252000 ## 5 FN1271000 ## 6 FN1286000 ## 7 FN1551000 ## 8 FN3235000 ## 9 FN3251000 ## 10 FN3252000 ## # ... with 198 more rows 8.4 From funds to entities If all you needed to do was get a list of allocation codes for your own research, then congrats, you’re done! But what if you want to take the next step, and find donors to those funds? You use one of the tools to find widgets to discover the gave_to_fund widget (read more at ?gave_to_fund). Though it looks on the surface pretty similar to gave_to_area and gave_to_department, it is in fact one of those second-order widgets! # gave_to_fund has the same interface/options # as gave_to_area and gave_to_department. diversity_donors = gave_to_fund(diversity_funds, at_least = 10000, from = 20150101, to = 20151231) display(diversity_donors) ## # A tibble: 27 x 1 ## entity_id ## &lt;dbl&gt; ## 1 867 ## 2 10469 ## 3 12100 ## 4 16607 ## 5 21393 ## 6 22653 ## 7 23207 ## 8 24473 ## 9 27771 ## 10 28097 ## # ... with 17 more rows 8.5 “Converters” Examples like this one show how higher-order widgets can act as “converters,” converting one type of definition (like allocation_code) to another (like entity_id). This is a handy idea to have in the back of your mind. If you find yourself with an ID list definition that has the wrong type of ID, see if you can find a second-order widget that will “convert” it to the right type. "],
["ex-political-economy.html", "9 Political economy list", " 9 Political economy list Here’s the request: Can you please generate a prospect list for me that includes econ, political economy, poli sci and business grads. And also include donors to Haas Center, Goldman School and CEGA? I start with the part I already know – business grads. library(discoveryengine) is_business_grad = has_degree_from(business) I believe Economics, Political Economy, and Political Science are all majors. I don’t know major codes, but most widgets have a built-in lookup feature: majored_in(?econ) ## synonym code ## pol_econ_of_indust_soc 697 ## urban_secondary_english 24903 ## political_economy 2B2 ## pol_econ_of_nat_resources 698 ## economics 246 ## agricultural_economics 024 ## environmental_econ_policy 779 ## household_arts_home_economics 373X ## agricultural_resource_economics 034 Ok, looks like economics and political_economy should definitely be included. What about political science? majored_in(?political) ## synonym code ## political_economy 2B2 ## political_science 699 So now I have what I need for the other graduates: is_poli_econ_grad = majored_in(political_science, political_economy, economics) Now I need to find donors to the Haas Center, Goldman School, and CEGA. Some follow-up clarified that the “Haas Center” here is referring to the Haas Institute for a fair and inclusive society . I don’t know if that is an area of giving, a department, a fund? So I use the brainstorm bot. From experience, I know that “institute” sometimes appears in CADS as the full word “institute” and is sometimes abbreviated to something like “inst.” I’ll use the wildcard (*) ability in the brainstorm bot to make sure I capture all possibilities: brainstorm_bot(&quot;haas inst*&quot;) ## attended_event ## 2843: Haas Institutional Analysis Workshop ## 4340: Haas Institutional Analysis Workshop ## gave_to_department ## HDRC: Haas Inst/Fair &amp; Inclusive Soc ## has_affiliation ## BUA18: Haas Inst of Mgmt, Innovation &amp; Org IMI ## BUBSI: Haas Institute for Bus &amp; Social Impact ## BUIBI: Haas Institute for Business Innovation Ah ha! It’s the department. is_haas_ctr_donor = gave_to_department(HDRC) CEGA is the “effective global action center.” Once again, I’ll ask the brainstorm bot for suggestions: brainstorm_bot(&quot;global action&quot;) ## gave_to_department ## CEGA: Effective Global Action Center is_cega_donor = gave_to_department(CEGA) I already happen to know that the Goldman School is an area of giving, so: is_goldman_donor = gave_to_area(public_policy) The request was for people who meet any of the given criteria, so I’ll use %or% to combine them: prospect_list = is_business_grad %or% is_poli_econ_grad %or% is_haas_ctr_donor %or% is_cega_donor %or% is_goldman_donor display(prospect_list) ## # A tibble: 83,461 x 1 ## entity_id ## &lt;dbl&gt; ## 1 2 ## 2 5 ## 3 13 ## 4 16 ## 5 28 ## 6 51 ## 7 78 ## 8 81 ## 9 98 ## 10 109 ## # ... with 83,451 more rows "],
["ex-lybunt.html", "10 LYBUNTs", " 10 LYBUNTs # i always begin by loading the disco engine if it isn&#39;t already loaded library(discoveryengine) Anyone involved in an annual solicitation cycle will have some interest in the population referred to as LYBUNT, which stands for Last Year But Not This Year. That is, someone who gave last year but has not given this year. How can we create such a definition in the Disco Engine? To make the example concrete, let’s say we’re identifying LYBUNTs for the school of Social Welfare. What I’d like to get to is: LYBUNT = last_year %but_not% this_year So, all I really need to do is define last_year and this_year. I’m writing this example in September, 2016, so I’ll define “last year” as FY2015-16, or in other words, July 1, 2015 - June 30, 2016: last_year = gave_to_area(social_welfare, from = 20150701, to = 20160630) And now for this year. Since the to argument is optional, I can just do: this_year = gave_to_area(social_welfare, from = 20160701) Now I can create my LYBUNT definition, as I strategized above: LYBUNT = last_year %but_not% this_year display(LYBUNT) ## # A tibble: 433 × 1 ## entity_id ## &lt;dbl&gt; ## 1 448 ## 2 500 ## 3 548 ## 4 3408 ## 5 8181 ## 6 9357 ## 7 9359 ## 8 9598 ## 9 9684 ## 10 10025 ## # ... with 423 more rows Finally, recall that every widget has a default set up if you don’t enter any codes. Looking at ?gave_to_area I can see that if I don’t use an area of giving codes, I just get any giving anywhere. I can use this knowledge to get campus-wide LYBUNTs: last_year = gave_to_area(from = 20150701, to = 20160630) this_year = gave_to_area(from = 20160701) LYBUNT = last_year %but_not% this_year display(LYBUNT) ## # A tibble: 63,319 × 1 ## entity_id ## &lt;dbl&gt; ## 1 3 ## 2 4 ## 3 7 ## 4 13 ## 5 16 ## 6 49 ## 7 59 ## 8 72 ## 9 94 ## 10 114 ## # ... with 63,309 more rows "],
["ex-recent-band-parents.html", "11 Recent Band Parents 11.1 Recent band members 11.2 Find their parents 11.3 Who live close enough 11.4 How many? 11.5 Householding", " 11 Recent Band Parents # always begin by loading the disco engine if it isn&#39;t already loaded library(discoveryengine) A client in Student Affairs is considering organizing a weekend event for parents of marching band members who graduated recently. They are tentatively holding the event at the Claremont Resort, but want to be sure that there are enough recent band parents who live close enough to attend. So our job is to build a definition of parents of recent band graduates who live near the Claremont Resort. Then we can just use display to view how many people fit the definition. 11.1 Recent band members First I need to find out how to identify marching band members. I’ll use the brainstorm bot: brainstorm_bot(&quot;marching band&quot;) ## participated_in ## MSMB: UC Marching Band Member Cool. So definining “recent” as anyone who graduated between 2010 and 2016: recent_band_member = participated_in(MSMB) %and% has_reunion_year(2010:2016) 11.2 Find their parents Since I’m already familiar with higher order widgets, I know what to do here: band_parent = parent_of(recent_band_member) 11.3 Who live close enough Here I’ll assume that 25 miles is about as far as we can expect one of these band parents to travel in order to attend the event. So my definition should include only those people who live within 25 miles of the Claremont Resort: event_prospect = band_parent %and% lives_near(&quot;Claremont Resort&quot;, miles = 25) ## Basing results on: Claremont Resort And Spa, Oakland, CA, USA (37.86, -122.24) ## (confidence that this is the right location: 0.903) 11.4 How many? Now I just use display and see the number of parents: display(event_prospect) ## # A tibble: 87 × 1 ## entity_id ## &lt;dbl&gt; ## 1 14999 ## 2 15672 ## 3 15687 ## 4 46204 ## 5 50302 ## 6 250310 ## 7 271059 ## 8 276471 ## 9 296428 ## 10 317956 ## # ... with 77 more rows Notice the first line, before the IDs start, tells us exactly how many individuals are on the list: 87. 11.5 Householding But hold up! Looking up some of these IDs, I’m noticing that both members of married couples are on the list. How many households are there here? I check the help for the display function by running ?display. And I notice that there is an option called household, and by default it is set to FALSE. So: display(event_prospect, household = TRUE) ## # A tibble: 48 × 1 ## entity_id ## &lt;dbl&gt; ## 1 14999 ## 2 317956 ## 3 347337 ## 4 874556 ## 5 889893 ## 6 907499 ## 7 988958 ## 8 780532 ## 9 910163 ## 10 910379 ## # ... with 38 more rows "],
["test-cdw.html", "A Test your database set up A.1 Test your connection A.2 Opening RStudio A.3 Installing getcdw A.4 Testing getcdw", " A Test your database set up A.1 Test your connection First, let’s make sure your connection works. You’ll need the user name and password you received from Nancy Fan. Here are the steps to see if that connection works: Navigate to C:\\Windows\\SysWOW64. Double click odbcad32. It’s the application highlighted in the following image: You’ll now have the ODBC Data Source Administrator open. Click the “System DSN” tab and then click the “Add..” button. Scroll down to close to the bottom of the list of drivers. There you’ll find “Oracle in instantclient_11_2”. Double click this. You’ll now be in a window that asks you for some information to configure this driver. Fill out the Data Source Name as “URELUAT” and find “URELUAT” in the dropdown menu for TNS Service Name. Enter your user name (the one given to you by Nancy, which is probably the same as your CalNet ID) as the User ID. Click “Test Connection”. Enter your password (given to you by Nancy) in the Password field. Click “OK”. You should now get a pop up message letting you know that the connection was successful. Click “OK” three times to close out the ODBC Source Administrator. If you did not get this message and instead got an error message, do not continue with the rest of these instructions until your connection is successful. You may have the wrong password, or there may be other connection issues. A.2 Opening RStudio If your connection was successful, let’s move on to setting up some packages you’ll need. First, open RStudio. If you don’t have an icon on your desktop, you can find the program by searching for “rstudio” in your Start menu. You’ll also find a copy at C:\\Program Files\\RStudio\\bin. If you want a shortcut on your desktop, simply drag and drop the rstudio application. When RStudio is open, you’ll see a few different panes on the screen. The console is where you can type commands and see output. We only need to worry about the console right now. It’s this part of the screen: You also want to make sure you’re using the correct version of R. Here are the steps to do so: Go to the Tools dropdown menu at the top of the screen, and select Global Options. You’ll see a box that looks like this: The top box tells you the R version you’re using. Click on the “Change..” button and make sure “[32-bit] C:\\Program Files\\R\\R-3.3.1” is selected. It looks like this: Click “Ok” twice. You may be prompted to restart the program. If so, go ahead and do so. A.3 Installing getcdw Before you can install getcdw, you’ll need to install a few packages. This can be done in a couple of ways, but perhaps the easiest is to enter the following into the console: install.packages(&quot;devtools&quot;) install.packages(&quot;dplyr&quot;, dependencies = TRUE) install.packages(&quot;S:/UR_Everyone/Rohit_Saini/ROracle/ROracle_1.2-2.zip&quot;, repos = NULL) You’ll then need to run this script. To do this, simply press enter after each line. There may be a pause for a few seconds during installation of the packages. A little stop sign will appear in the upper right corner of the console while the script is running. Once this stop sign is gone, you should get an output message that tells you that each package has been successfully unpacked and where the downloaded packages are stored. You’re now ready to move on to the next line. Tip: Copy and paste each line of the above code directly into your console and press enter after each time. This will avoid typos and will help narrow down what went wrong if something doesn’t work. Now go ahead and use devtools to install getcdw. You’ll need to run code that looks like this: devtools::install_github(&quot;tarakc02/getcdw&quot;) You should get a message that getcdw has been installed. Again there may be a pause while the package is being installed. A.4 Testing getcdw Let’s go ahead and load the library for getcdw: library(getcdw) Copy the above into your console and press enter. It will appear that nothing happened, but that actually means everything is fine. Now all we need to do is run a simple query to test the connection. We’ll do this by entering a SQL query into the console and seeing if it returns valid data (which would mean that you are able to connect to the database). When you do so, you’ll be prompted for some information, please read the instructions below and make sure you understand what you’re supposed to enter: get_cdw(&quot;select * from dual&quot;) When you do this for the first time, you will be prompted for three pieces of information: Your “UID”: This is your username to log-in to the database. Unless you were told otherwise, this should be the same as your CalNet ID Your “PWD”: This is the password to log-in to the database. You should have received this from Nancy Fan, and it looks like a long random set of characters, numbers, and other symbols: Finally, you’ll be prompted for a “secret passphrase.” The database password is long and confusing and impossible to remember, which encourages most of us to write it down somewhere and keep it near the computer, which is insecure! So instead getcdw allows you to pick your own secret passphrase (this can be anything, from a single word to a memorable sentence, or whatever you think is easy for you to remember but not easy for someone else to guess). After this step, you will only ever be required to enter your secret passphrase – you will no longer be prompted for your database UID or PWD. If everything is working properly, you should see something like this: ## # A tibble: 1 × 1 ## dummy ## &lt;chr&gt; ## 1 X If that’s what you see, you are all set! Stay tuned for further instructions as we work to roll out the new suite of tools! "],
["cheat-sheet.html", "B Cheat Sheet B.1 Getting started B.2 Output B.3 Code lookup B.4 The best widgets for . . . B.5 Text search B.6 Other", " B Cheat Sheet B.1 Getting started Always start a session with library(discoveryengine) library(discoveryengine) Not sure where to begin? Use show_widgets() to view a searchable and sortable list of available widgets. For more tips on finding widgets, check out the section on finding widgets. Still not sure what to do? Try using the brainstorm bot. For instance if you are looking for people who played on the basketball team, type brainstorm_bot(&quot;basketball&quot;) Multiple widgets can be combined using the operators %and%, %or%, or %but_not%. For example, gave_to_area(natural_resources) %but_not% in_unit_portfolio(natural_resources) B.2 Output Use display for output. Recall that you can use the equals sign = to assign names to your disco engine definitions, to make it easier to refer to them when displaying or doing other operations: basketball_player = played_sport(basketball_men, basketball_women) display(basketball_player) ## # A tibble: 444 × 1 ## entity_id ## &lt;dbl&gt; ## 1 370 ## 2 1429 ## 3 1495 ## 4 3615 ## 5 4425 ## 6 5946 ## 7 6412 ## 8 6882 ## 9 7539 ## 10 7659 ## # ... with 434 more rows If instead of just viewing IDs on the screen, you’d like to export them (perhaps to use in a CADS savedlist), just add a filename: display(basketball_player, file = &quot;basketball-players&quot;) and a file called “basketball-players.csv” will appear in your working directory. Note that the exported file has a header, so when you upload it to an Advance savedlist, make sure to check the “First row is a header” box. B.3 Code lookup Most widgets rely on the coding found in CADS for their input, but you probably haven’t memorized all of the codes! By using a question-mark inside of a widget, you can do look-ups on the fly: gave_to_department(?band) ## synonym code ## cal_band CALBAND Codes (such as CALBAND) and synonyms (such as cal_band) can be used interchangeably, so use whichever feels more comfortable. B.4 The best widgets for . . . The following may be incomplete and is not a substitute for using show_widgets(), but may come in handy in a pinch. Find out more about any one of these by using the built-in help. For example, to learn more about the gave_to_area widget, type ?gave_to_area Giving widgets: gave_to_area, gave_to_department, gave_to_fund Ratings: has_capacity, has_implied_capacity, has_major_gift_score, has_gift_planning_score Academic and student experience: has_degree_from, majored_in, participated_in, played_sport, received_award UCB affiliations: has_affiliation, on_committee, received_award Interests, etc: has_interest, has_philanthropic_affinity Employment: works_in_industry, has_occupation Geography: lives_in_county, lives_in_msa, lives_in_zip, lives_near, works_in_county, works_in_msa, works_in_zip, works_near B.5 Text search Though most widgets rely on codes from CADS as inputs, some are search-based. Just like the brainstorm_bot, which is also based on text search, these widgets require you to use quotation marks around the search term(s). Here are some examples: contact_text_contains(&quot;neuroscience&quot;) fund_text_contains(&quot;diversity&quot;) research_miner(&quot;underrepresented&quot;) Note: The brainstorm_bot will help you find things through the code tables, but it will not do big text searches of things like contact reports, fund biographies/terms, and research profiles. For that kind of specialized search, you should use these text search based widgets. B.6 Other Type show_suspect_pools() to view a list of all Suspect Pools, which is useful in conjunction with the in_suspect_pool widget. "]
]
